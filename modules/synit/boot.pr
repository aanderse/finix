# Initial configuration for the syndicate-server acting as the Synit system bus.

# Sending <exec/restart SOMECOMMAND RESTARTPOLICY> causes the command to be run.
#
?? <exec/restart ?argv ?restartPolicy> [
  let ?id = timestamp
  let ?facet = facet
  let ?d = <temporary-exec $id $argv>
  <run-service <daemon $d>>
  <daemon $d {
    argv: $argv,
    readyOnStart: #f,
    restart: $restartPolicy,
  }>
  ? <service-state <daemon $d> complete> [$facet ! stop]
  ? <service-state <daemon $d> failed>   [$facet ! stop]
]

# If the restart policy is not specified, it is defaulted to `on-error`.
#
?? <exec ?argv> ! <exec/restart $argv on-error>

# Define the mechanics of milestone services.
#
# To "run" a milestone service,
#  - assert that it is both started and ready
#  - that's it!
#
? <run-service <milestone ?m>> [
  <service-state <milestone $m> started>
  <service-state <milestone $m> ready>
  $log ! <log "-" { service: <milestone $m> state: up }>
  ?- <log "-" { service: <milestone $m> state: down }>
]

# To the usual suite of service states we add `up`, meaning "either `ready` or `complete`".
#
? <service-state ?x ready> <service-state $x up>
? <service-state ?x complete> <service-state $x up>


# The machine dataspace contains the active extensional configuration of the system.
#
let ?machineDataspace = dataspace
$machineDataspace ? ?ass [
  $log ! <log "-" { line: "machine" |+++|: $ass }>
  ?- $log ! <log "-" { line: "machine" |---|: $ass }>
]
$machineDataspace ?? ?msg [
  $log ! <log "-" { line: "machine" |!!!|: $msg }>
]

<run-service <config-watcher "/run/synit/config/machine" {
  config: $machineDataspace
  log: $log
}>>


# The network dataspace contains intentional configuration.
#
let ?networkDataspace = dataspace
$networkDataspace ? ?x [
  $log ! <log "-" { line: "network" |+++|: $x }>
  ?- $log ! <log "-" { line: "network" |---|: $x }>
]
$networkDataspace ?? ?msg [
  $log ! <log "-" { line: "network" |!!!|: $msg }>
]
<run-service <config-watcher "/run/synit/config/network" {
  config: $networkDataspace
  log: $log
}>>


# The core dataspace contains daemons that are required by and are
# persistent across plans.

# Attenuate `$config` by rewriting plain `require-service` assertions to `require-core-service`
# assertions. Allow all other assertions through.
#
let ?coreConfig = <* $config [<or [
  <rewrite <require-service ?s> <require-core-service $s>>
  <accept _>
]>]>

# Give meaning to `require-core-service`: it is an ordinary `require-service`, plus a
# declaration that the `core` milestone depends on the service.
#
? <require-core-service ?s> [
  <depends-on <milestone core> <service-state $s up>>
  <require-service $s>
]

# Load config in the `core` directory, using the wrapped `config` so that all plain services
# required are changed to be *core* services.
#
<require-core-service <config-watcher "/etc/syndicate/core" {
  config: $coreConfig
  gatekeeper: $gatekeeper
  log: $log
  machine: $machineDataspace
  network: $networkDataspace
}>>


# Self-declared service states.
#
<run-service <config-watcher "/run/synit/config/state" {
  config: <* $config [ <reject <not <rec service-state { }>>> ]>
}>>


# Persistent daemons.
#
? <persist <daemon ?label ?attrs>> [
  # Assert the daemon specification.
  $config += <daemon $label $attrs>
  # Run the daemon immediately irregardless of dependencies.
  $config += <run-service <daemon $label>>
]
# Watch a directory for persistent daemons.
<run-service <config-watcher "/run/synit/config/persistent" {
  config: <* $config [ <or [
      # Rewrite daemon assertions and handle them in $config.
      <rewrite <daemon ?label ?attrs> <persist <daemon $label $attrs>> >
      # Everything else is asserted as-is.
      <accept _>
    ]> ]>
  log: $log
}>>


# Answer question $a with the aswer to question $b.
? <chain-q-a ?a ?b> [
  <q $a>
  ? <a $a ?resp> [
    <a $b $resp>
  ]
]

# Plans.

# Any service required in a plan requires the core
# and is required by the plan milestone.
? <require-plan-service ?plan ?service> [
  <depends-on $plan <service-state $service up>>
  <depends-on $service <service-state <milestone core> up>>
]

# Activate a plan by a message.
?? <activate <plan ?planName ?planPath ?script>> [
  let ?plan = <plan $planName $planPath $script>

  # Deactivate the plan by an assertion.
  let ?planFacet = facet
  ? <deactivate $plan> [ $planFacet ! stop ]

  # Assert deactivation of this plan when prompted by a message.
  ?? <deactivate <plan $planName> ?cap> [
    $cap += <deactivate $plan>
  ]

  # When the activation script completes send
  # the deactivation message.
  # The message contains a an attenuation of $config
  # that prevents this plan from deactivation itself.
  ? <service-state <daemon $plan> complete> [
    let ?att = <* $config [ <reject <deactivate $plan> > ]>
    ! <deactivate <plan $planName> $att>
  ]

  # The plan configuration is loaded into the system-bus
  # with the caveat that any <require-service> becomes
  # a <require-plan-service $plan> at $config.
  let ?planConfig = <* $config [ <or [
      <rewrite <require-service ?service> <require-plan-service $plan $service>>
      <accept _>
    ]> ]>

  # A service to watch the configuration at the $planPath.
  let ?planWatcher = <config-watcher $planPath {
      config: $planConfig
      gatekeeper: $gatekeeper
      log: $log
      machine: $machineDataspace
      network: $networkDataspace
    }>

  # The plan <depends-on> <config-watcher $planPath>.
  $planConfig += <require-service $planWatcher>

  # The config-watcher depends on activation succeding.
  <depends-on $planWatcher <service-state <daemon $plan> complete>>
  <depends-on <daemon $plan> <service-state <milestone core> up>>

  <daemon $plan {
      argv: $script
      restart: never
    }>

  # Require the plan.
  <require-service $plan>
]

# Plans reuse the semantics of milestones.
? <run-service <plan ?name ?path ?script>> [
  let ?plan = <plan $name $path $script>
  <service-state $plan started>
  <service-state $plan ready>
  $log ! <log "plans" { service: $plan state: up }>
  ?- <log "plans" { service: $plan state: down }>
]

# Watch for plans to activate.
<require-service <config-watcher "/run/synit/config/plans" {
    config: <* $config [ <accept <activate <plan _ _ _>> > ]>
  }>>
